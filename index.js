#!/usr/bin/env node
// Generated by LiveScript 1.3.1
(function(){
  var docopt, glob, jade, _, bb, beml, parse, sh, fs, doc, md, Remarkable, o, readJson, renderJson, data, directory, filenames, dest, fn;
  docopt = require('docopt').docopt;
  glob = require('glob');
  jade = require('jade');
  _ = require('underscore');
  bb = require('bluebird');
  beml = require('beml');
  parse = require('./parse').parse;
  sh = bb.promisifyAll(require('shelljs'));
  fs = require('fs');
  doc = "\nUsage:\n    json2html-cli markdown [ input | directory DIR -d DEST ] -t TEMPLATE -c CONFIG \n    json2html-cli html directory DIR -d DEST \n    json2html-cli -v | -h | --help \n\nOptions: \n    -t TEMPLATE   Jade template that expands the `post.contents` \n    -c CONFIG     JSON configuration file of the site (has a `baseUrl` property)\n    -d DEST    \n\nArguments: \n    DIR         Source directory\n\nDescription: \n    Command `markdown` converts markdown files to `.json` by: \n\n        - rendering markdown with marked \n\n        - rendering the blog post with jade template TEMPLATE \n\n    It generates a json where the `post.contents` property\n    has been filled with the generated html. Either accepts\n    a file from standard input (`input` command) or \n    a directory with markdown files (DIR).\n\n    Command `html` generates the final `html` in DEST for \n    each `json` file in DIR.";
  md = {};
  if (false) {
    Remarkable = require('remarkable');
    md.render = new Remarkable().render;
  } else {
    md.render = require('marked');
  }
  o = docopt(doc);
  console.log(o);
  fs = bb.promisifyAll(fs);
  readJson = function(it){
    return JSON.parse(fs.readFileSync(it, 'utf-8'));
  };
  renderJson = function(jj){
    var conf, locals, template, result;
    jj.post.contents = md.render(jj.mdContent);
    conf = readJson(o['-c']);
    locals = {
      post: jj.post,
      filename: o['-t'],
      pretty: true
    };
    locals = _.extend(locals, conf);
    template = fs.readFileSync(o['-t'], 'utf-8');
    result = jade.compile(template, locals)(locals);
    result = beml.process(result);
    delete jj.post.contents;
    jj.post.htmlContent = result;
    return jj;
  };
  if (o['markdown']) {
    if (!o['directory']) {
      data = {};
      if (o['input']) {
        data = parse(fs.readFileSync('/dev/stdin', 'utf-8'));
      } else {
        throw "not supported";
      }
      renderJson(data);
      console.log(JSON.stringify(data, 0, 4));
    } else {
      directory = o["DIR"];
      filenames = glob.sync(directory + "/*.md");
      dest = o["-d"];
      sh.execAsync("mkdir -p " + dest, {
        async: true
      }).then(function(){
        var fn;
        fn = filenames.map(function(f){
          return fs.readFileAsync(f, 'utf-8').then(function(it){
            var data, rendered;
            data = parse(it);
            rendered = renderJson(data);
            console.log("Writing " + dest + "/" + rendered.post.fileName + ".json ");
            return fs.writeFileAsync(dest + "/" + rendered.post.fileName + ".json", JSON.stringify(rendered, 0, 4), 'utf-8');
          });
        });
        return bb.all(fn).then(function(){
          return console.log("done");
        });
      });
    }
  } else {
    if (!o['directory']) {
      data = {};
      if (o['input']) {
        data = JSON.parse(fs.readFileSync('/dev/stdin', 'utf-8'));
      } else {
        data = readJson(o["JSON"]);
      }
      renderJson(data);
      console.log(JSON.stringify(data, 0, 4));
    } else {
      directory = o["DIR"];
      filenames = glob.sync(directory + "/*.json");
      dest = o["-d"];
      fn = filenames.map(function(f){
        return fs.readFileAsync(f, 'utf-8').then(function(it){
          var post;
          post = JSON.parse(it).post;
          return sh.execAsync("mkdir -p " + dest + "/" + post.dirName, {
            async: true
          }).then(function(){
            return fs.writeFileAsync(dest + "/" + post.dirName + "/" + post.fileName + ".html", post.htmlContent, 'utf-8');
          });
        });
      });
      bb.all(fn).then(function(){
        return console.log("done");
      });
    }
  }
}).call(this);
